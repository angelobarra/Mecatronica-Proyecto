// Code generated by Icestudio 0.10-rc1

`default_nettype none

//---- Top entity
module main #(
 parameter v2e4d79 = 1
) (
 input ve48d8d,
 input vclk,
 output vd85cb9,
 output [3:0] v351668,
 output [0:2] vinit
);
 localparam p3 = v2e4d79;
 wire w0;
 wire [0:7] w1;
 wire w2;
 wire w4;
 wire [0:3] w5;
 wire w6;
 wire [0:3] w7;
 wire [0:3] w8;
 wire w9;
 wire w10;
 assign w0 = ve48d8d;
 assign vd85cb9 = w4;
 assign v351668 = w8;
 assign w9 = vclk;
 assign w10 = vclk;
 assign w6 = w4;
 assign w10 = w9;
 vb9ce14 vce97e0 (
  .v6a1cbe(w0),
  .v2d03ef(w1),
  .ve77bd8(w2),
  .v7114a9(w9)
 );
 main_vf24429 vf24429 (
  .caracteres(w1),
  .estado(w5)
 );
 v56885a #(
  .v187a47(p3)
 ) vffccdf (
  .v6e1dd1(w2),
  .veabfb2(w4),
  .v5688a8(w10)
 );
 vcd03fe vfe99d9 (
  .v54ac99(w5),
  .v2d3366(w6),
  .ve2616d(w7),
  .v6833fd(w8)
 );
 v1740c5 vc3db2f (
  .v919d0f(w7)
 );
 assign vinit = 3'b000;
endmodule

//---- Top entity
module vb9ce14 #(
 parameter v47d474 = 115200
) (
 input v7114a9,
 input v6a1cbe,
 output [7:0] v2d03ef,
 output ve77bd8,
 output v6a2ebd
);
 localparam p4 = v47d474;
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w5;
 assign w0 = v7114a9;
 assign w1 = v6a1cbe;
 assign v2d03ef = w2;
 assign v6a2ebd = w3;
 assign ve77bd8 = w5;
 vb9ce14_vf55761 #(
  .BAUD(p4)
 ) vf55761 (
  .clk(w0),
  .RX(w1),
  .data(w2),
  .rcv(w3),
  .busy(w5)
 );
endmodule

//---------------------------------------------------
//-- Serial-rx
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Receptor serie asíncrono. Velocidad por defecto: 115200 baudios
//---------------------------------------------------

module vb9ce14_vf55761 #(
 parameter BAUD = 0
) (
 input clk,
 input RX,
 output [7:0] data,
 output busy,
 output rcv
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 
 
 //-- Calcular el numero de bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d1;
 reg din;
 
 always @(posedge clk)
  d1 <= RX;
  
 //-- Din contiene el dato serie de entrada listo para usarse   
 always @(posedge clk)
   din <= d1;
   
 //------ Detectar el bit de start: flanco de bajada en din
 
 //-- Registro temporal
 reg q_t0 = 0;
 
 always @(posedge clk)
   q_t0 <= din;
   
 //-- El cable din_fe es un "tic" que aparece cuando llega el flanco de 
 //-- bajada
 wire din_fe = (q_t0 & ~din);
 
 //-------- ESTADO DEL RECEPTOR
 
 //-- 0: Apagado. Esperando
 //-- 1: Encendido. Activo. Recibiendo dato
 reg state = 0;
 
 always @(posedge clk)
   //-- Se pasa al estado activo al detectar el flanco de bajada
   //-- del bit de start
   if (din_fe)
     state <= 1'b1;
     
   //-- Se pasa al estado inactivo al detectar la señal rst_state    
   else if (rst_state)
     state<=1'b0;
 
 //------------------ GENERADOR DE BAUDIOS -----------------------------
 //-- Se activa cuando el receptor está encendido
 
 
 //-- Calcular la mitad del divisor BAUDRATE/2
 localparam BAUD2 = (BAUDRATE >> 1);
 
 //-- Contador del sistema, para esperar un tiempo de  
 //-- medio bit (BAUD2)
 
 //-- NOTA: podria tener N-2 bits en principio
 reg [N-1: 0] div2counter = 0;
 
 //-- Se genera primero un retraso de BAUD/2
 //-- El proceso comienza cuando el estado pasa a 1
 
 always @(posedge clk)
 
   //-- Contar
   if (state) begin
     //-- Solo cuenta hasta BAUD2, luego  
     //-- se queda en ese valor hasta que
     //-- ena se desactiva
     if (div2counter < BAUD2) 
       div2counter <= div2counter + 1;
   end else
     div2counter <= 0;
 
 //-- Habilitar el generador de baudios principal
 //-- cuando termine este primer contador
 wire ena2 = (div2counter == BAUD2);
 
 
 //------ GENERADOR DE BAUDIOS PRINCIPAL
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Esta señal contiene el tic
 wire ov = (divcounter == BAUDRATE-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena2 == 0);
 
 //-- El cable con el tic para capturar cada bit lo llamamos
 //-- bit_tic, y es la señal de overflow del contador
 wire bit_tic = ov;
 
 //-------- REGISTRO DE DESPLAZAMIENTO -----------
 //-- Es el componente que pasa los bits recibidos a paralelo
 //-- La señal de desplazamiento usada es bit_tic, pero sólo cuando  
 //-- estamos en estado de encendido (state==1)
 //-- Es un registro de 9 bits: 8 bits de datos + bit de stop
 //-- El bit de start no se almacena, es el que ha servido para
 //-- arrancar el receptor
 
 reg [8:0] sr = 0;
 
 always @(posedge clk)
   //-- Se captura el bit cuando llega y el receptor
   //-- esta activado
   if (bit_tic & state)
     sr <= {din, sr[8:1]};
     
 //-- El dato recibido se encuentran en los 8 bits menos significativos
 //-- una vez recibidos los 9 bits
 
 //-------- CONTADOR de bits recibidos
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [4:0] cont = 0;
 
 always @(posedge clk)
 
   //-- El contador se pone a 0 si hay un overflow o 
   //-- el receptor está apagado 
   if ((state==0)| ov2)
     cont <= 0;
   else
     //-- Receptor activado: Si llega un bit se incrementa
     if (bit_tic)
       cont <= cont + 1;
       
 //-- Comprobar overflow
 wire ov2 = (cont == 9);
     
 //-- Esta señal de overflow indica el final de la recepción
 wire fin = ov2;
 
 //-- Se conecta al reset el biestable de estado
 wire rst_state = fin;
 
 //----- REGISTRO DE DATOS -------------------
 //-- Registro de 8 bits que almacena el dato final
 
 //-- Bus de salida con el dato recibido
 reg data = 0;
 
 always @(posedge clk)
 
   //-- Si se ha recibido el ultimo bit, capturamos el dato
   //-- que se encuentra en los 8 bits de menor peso del
   //-- registro de desplazamiento
   if (fin)
     data <= sr[7:0];
 
 //-- Comunicar que se ha recibido un dato
 //-- Tic de dato recibido
 reg rcv = 0;
 always @(posedge clk)
   rcv <= fin;
 
 //-- La señal de busy es directamente el estado del receptor
 assign busy = state;
 
 
endmodule
//---- Top entity
module v56885a #(
 parameter v187a47 = 1
) (
 input v5688a8,
 input v6e1dd1,
 output veabfb2,
 output va9e2af
);
 localparam p0 = v187a47;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 assign w1 = v6e1dd1;
 assign veabfb2 = w2;
 assign va9e2af = w3;
 assign w4 = v5688a8;
 v56885a_v3140f5 #(
  .SEG(p0)
 ) v3140f5 (
  .start(w1),
  .p(w2),
  .tic(w3),
  .clk(w4)
 );
endmodule

//---------------------------------------------------
//-- timer-sec
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Temporizador en segundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar
//---------------------------------------------------

module v56885a_v3140f5 #(
 parameter SEG = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //localparam SEC;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el corazon
 wire rst_heart;
 
 //-- Overflow del temporizador del corazon
 wire ov_heart;
 
 //-- Habilitacion del corazon
 wire ena;
 
 //-- Tics del corazon
 wire tic_heart;
 
 //-- Contador del corazon
 reg [N-1:0] heart=0;
 
 always @(posedge clk)
   if (rst_heart)
     heart <= 0;
   else
     heart <= heart + 1;
 
 //-- Overflow del contador
 assign ov_heart = (heart == M-1);
 
 //-- La salida del corazon es la señal de overflow
 assign tic_heart = ov_heart;
 
 //-- Reset del corazon
 assign rst_heart =~ena | ov_heart;
 
 
 
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 reg [7:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
 if (rst)
   counter <= 0;
 else
   if (tic_heart)
     counter <= counter + 1;
 
 //-- Evento: cuenta máxima de tics alcanzada
 assign ov = (counter == SEG);
 
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 assign ena = ~rst;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
 
endmodule
//---- Top entity
module vcd03fe (
 input [3:0] v54ac99,
 input [3:0] ve2616d,
 input v2d3366,
 output [3:0] v6833fd
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:3] w3;
 wire w4;
 wire [0:3] w5;
 wire [0:3] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 assign v6833fd = w3;
 assign w5 = ve2616d;
 assign w6 = v54ac99;
 assign w9 = v2d3366;
 assign w10 = v2d3366;
 assign w11 = v2d3366;
 assign w12 = v2d3366;
 assign w10 = w9;
 assign w11 = w9;
 assign w11 = w10;
 assign w12 = w9;
 assign w12 = w10;
 assign w12 = w11;
 vd0c4e5 v6d94c9 (
  .v030ad0(w0),
  .v2d3366(w11),
  .v27dec4(w15),
  .vb192d0(w17)
 );
 vd0c4e5 vebe465 (
  .v030ad0(w1),
  .v2d3366(w12),
  .v27dec4(w16),
  .vb192d0(w18)
 );
 vd0c4e5 ve1c21f (
  .v030ad0(w2),
  .v2d3366(w10),
  .v27dec4(w13),
  .vb192d0(w14)
 );
 v84f0a1 va44bdf (
  .vee8a83(w0),
  .v03aaf0(w1),
  .vf8041d(w2),
  .v11bca5(w3),
  .vd84a57(w4)
 );
 vd0c4e5 v2ebff3 (
  .v030ad0(w4),
  .v27dec4(w7),
  .vb192d0(w8),
  .v2d3366(w9)
 );
 vc4f23a v3c3a57 (
  .v985fcb(w5),
  .v4f1fd3(w8),
  .vda577d(w14),
  .v3f8943(w17),
  .v64d863(w18)
 );
 vc4f23a vd6d480 (
  .v985fcb(w6),
  .v4f1fd3(w7),
  .vda577d(w13),
  .v3f8943(w15),
  .v64d863(w16)
 );
endmodule

//---------------------------------------------------
//-- 4-bits-Mux-2-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (4-bit channels)
//---------------------------------------------------
//---- Top entity
module vd0c4e5 (
 input v27dec4,
 input vb192d0,
 input v2d3366,
 output v030ad0
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign v030ad0 = w0;
 assign w2 = v2d3366;
 assign w3 = v2d3366;
 assign w6 = v27dec4;
 assign w7 = vb192d0;
 assign w3 = w2;
 v873425 vaaee1f (
  .vcbab45(w0),
  .v0e28cb(w1),
  .v3ca442(w4)
 );
 vba518e v569873 (
  .vcbab45(w1),
  .v3ca442(w2),
  .v0e28cb(w6)
 );
 v3676a0 v1f00ae (
  .v0e28cb(w3),
  .vcbab45(w5)
 );
 vba518e vc8527f (
  .vcbab45(w4),
  .v3ca442(w5),
  .v0e28cb(w7)
 );
endmodule

//---------------------------------------------------
//-- Mux-2-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 2-to-1 Multplexer (1-bit channels)
//---------------------------------------------------
//---- Top entity
module v873425 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v873425_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- OR2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- OR2: Two bits input OR gate
//---------------------------------------------------

module v873425_vf4938a (
 input a,
 input b,
 output c
);
 //-- OR Gate
 //-- Verilog implementation
 
 assign c = a | b;
 
 
endmodule
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule
//---- Top entity
module v84f0a1 (
 input vd84a57,
 input vf8041d,
 input vee8a83,
 input v03aaf0,
 output [3:0] v11bca5
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 assign w0 = vee8a83;
 assign w1 = v03aaf0;
 assign w2 = vf8041d;
 assign w3 = vd84a57;
 assign v11bca5 = w4;
 v84f0a1_v9a2a06 v9a2a06 (
  .i1(w0),
  .i0(w1),
  .i2(w2),
  .i3(w3),
  .o(w4)
 );
endmodule

//---------------------------------------------------
//-- Bus4-Join-all
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus4-Join-all: Join all the wires into a 4-bits Bus
//---------------------------------------------------

module v84f0a1_v9a2a06 (
 input i3,
 input i2,
 input i1,
 input i0,
 output [3:0] o
);
 assign o = {i3, i2, i1, i0};
 
endmodule
//---- Top entity
module vc4f23a (
 input [3:0] v985fcb,
 output v4f1fd3,
 output vda577d,
 output v3f8943,
 output v64d863
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:3] w4;
 assign v3f8943 = w0;
 assign v64d863 = w1;
 assign vda577d = w2;
 assign v4f1fd3 = w3;
 assign w4 = v985fcb;
 vc4f23a_v9a2a06 v9a2a06 (
  .o1(w0),
  .o0(w1),
  .o2(w2),
  .o3(w3),
  .i(w4)
 );
endmodule

//---------------------------------------------------
//-- Bus4-Split-all
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus4-Split-all: Split the 4-bits bus into its wires
//---------------------------------------------------

module vc4f23a_v9a2a06 (
 input [3:0] i,
 output o3,
 output o2,
 output o1,
 output o0
);
 assign o3 = i[3];
 assign o2 = i[2];
 assign o1 = i[1];
 assign o0 = i[0];
endmodule
//---- Top entity
module v1740c5 #(
 parameter vfffc23 = 1
) (
 output [3:0] v919d0f
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign v919d0f = w1;
 v9b9118 #(
  .vc5c8ea(p0)
 ) v76a485 (
  .v1ef182(w1)
 );
endmodule

//---------------------------------------------------
//-- 4bits-Value_1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 4bits constant value: 1
//---------------------------------------------------
//---- Top entity
module v9b9118 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v1ef182
);
 localparam p0 = vc5c8ea;
 wire [0:3] w1;
 assign v1ef182 = w1;
 v9b9118_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

//---------------------------------------------------
//-- 4-bits-gen-constant
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Generic: 4-bits generic constant (0-15)
//---------------------------------------------------

module v9b9118_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule

module main_vf24429 (
 input [7:0] caracteres,
 output [3:0] estado
);
 reg[3:0] s;
 
 always @*
 begin
 if(caracteres == "W")
    begin
     s = 4'b1001; 
    end
    
 else if(caracteres == "S")
     begin
      s = 4'b0001; 
     end
 
 else if(caracteres == "A")
     begin
      s = 4'b0100; 
     end    
 else if(caracteres == "D")
     begin
      s = 4'b0110; 
     end
 else 
    begin
     s = 4'b0101; 
    
    end
 
 end
 
 assign estado = s;
     
 
     
endmodule
